# 🗺️ 寻路算法可视化 | Pathfinding Visualizer

> 🎯 一个功能完整的寻路算法可视化工具，支持A*、Dijkstra、BFS等多种算法的实时动画演示

---

🚀 **实时可视化 · 多种算法 · 交互式界面 · 动画演示**

---

## 📚 项目简介

本项目是一个**完整的可视化教学工具**，专门用于演示和比较不同的寻路算法。相比于普通的算法实现，本项目更侧重于**直观的视觉效果和交互式学习体验**。

### 🎯 项目特色

- ✅ **实时动画**: 逐步展示算法搜索过程，直观理解算法原理
- ✅ **多算法支持**: A*、Dijkstra、BFS三种经典寻路算法
- ✅ **交互式编辑**: 可自由设置障碍物、起点和终点
- ✅ **性能优化**: 支持大场地渲染和速度调节
- ✅ **响应式设计**: 适配桌面和移动设备
- ✅ **LLM算法生成**: 🤖 支持通过AI生成自定义寻路算法
- ✅ **多API支持**: 集成魔搭社区、硅基流动、DeepSeek、OpenRouter四大平台

---

## 🚀 功能特性

### 🧭 算法支持
- **A* 算法** ⭐ - 启发式搜索，效率最优
- **Dijkstra 算法** - 经典最短路径算法
- **广度优先搜索 (BFS)** - 简单直观的搜索策略

### 📏 场地大小选择
- **小场地 (20x20)** 🎯 - 默认推荐，快速测试
- **中场地 (30x30)** 📐 - 适中复杂度，平衡演示效果
- **大场地 (40x40)** 🏗️ - 挑战级别，测试算法性能

### ⚡ 探路速度控制
- **最快** 🚀 - 基本无延迟，快速查看结果
- **中等** ⏱️ - 适中的动画速度，便于观察
- **最慢** 🐌 - 详细动画，清楚展示每一步搜索

### 🛠️ 高级功能
- 对角线移动选项支持
- 多种启发式函数（曼哈顿距离、欧几里得距离、对角距离）
- 实时可视化搜索过程
- 交互式网格编辑（设置障碍物、起点、终点）
- 动画效果展示寻路过程

### 🤖 LLM 算法生成功能
- **智能算法生成**: 使用自然语言描述算法，AI自动生成可执行代码
- **多平台API支持**: 支持魔搭社区、硅基流动、DeepSeek、OpenRouter四大平台
- **实时执行测试**: 生成后立即在当前网格中测试运行
- **安全代码执行**: 带有沙箱保护的代码执行环境
- **算法管理**: 支持多个自定义算法的保存、删除和选择

#### 🚀 支持的 LLM 提供商
| 提供商 | 推荐模型 | 特点 |
|--------|----------|------|
| 🏗️ **魔搭社区** | Qwen/Qwen2.5-72B-Instruct | 中文支持优秀，适合算法理解 |
| ⚡ **硅基流动** | Qwen/Qwen2.5-72B-Instruct | 性价比高，响应速度快 |
| 🧠 **DeepSeek** | deepseek-chat | 代码生成能力强，逻辑推理优秀 |
| 🌐 **OpenRouter** | anthropic/claude-3.5-sonnet | 多模型支持，选择灵活 |

---

## 💻 安装和运行

### 1. 系统要求

- **操作系统**: Windows 10/11, macOS, Linux
- **Python版本**: 3.6 或更高版本
- **内存**: 至少512MB RAM
- **浏览器**: 现代Web浏览器（Chrome、Firefox、Safari、Edge）

### 2. 安装依赖

```bash
# 克隆项目
git clone https://github.com/LimbusSpace/pathfinding-visualizer.git
cd pathfinding-visualizer

# 安装Python依赖
pip install -r requirements.txt
```

### 4. LLM功能配置（可选）

如果需要使用LLM算法生成功能，请按以下步骤配置：

#### 获取API密钥
选择一个或多个LLM提供商并注册账号获取API密钥：

- **魔搭社区**: https://modelscope.cn
- **硅基流动**: https://siliconflow.cn
- **DeepSeek**: https://platform.deepseek.com
- **OpenRouter**: https://openrouter.ai

#### 配置密钥
1. 启动应用后，点击"设置 LLM"按钮
2. 选择你使用的API提供商
3. 输入对应的API密钥
4. 点击"测试连接"验证配置
5. 配置成功后即可使用AI算法生成功能

#### 查看详细指南
详细的LLM功能使用说明请参考：[LLM使用指南.md](./LLM使用指南.md)

### 5. 启动应用

#### 方法一：Python命令启动
```bash
python app.py
```

#### 方法二：Windows一键启动（推荐）
```bash
# Windows用户双击运行
启动寻路可视化.bat
```

### 4. 访问应用

打开浏览器访问：`http://localhost:5000`

浏览器将自动打开，如果没有请手动输入上述地址。

---

## 🎮 使用方法

### 初次使用快速开始

1. 📍 **选择场地大小**：从"场地大小"下拉菜单选择小、中、大场地
2. ⚡ **选择探路速度**：从"探路速度"下拉菜单选择最快、中等、最慢
3. 🔄 **初始化网格**：点击"初始化网格"按钮
4. 🚩 **设置起点**：右键点击网格中的任意位置
5. 🎯 **设置终点**：中键点击网格中的任意位置
6. 🧱 **绘制障碍物**：左键点击和拖拽绘制障碍物
7. 🧮 **选择算法**：从"算法选择"下拉菜单选择寻路算法
8. ▶️ **开始寻路**：点击"开始寻路"按钮观看算法执行过程

### LLM 算法生成使用
1. 🤖 **配置LLM**：点击"设置 LLM"按钮，选择提供商并输入API密钥
2. 📝 **描述算法**：在"算法描述"中用自然语言描述你想要的算法
3. 🏷️ **命名算法**：为你的算法起一个名字
4. 🚀 **生成算法**：点击"生成算法"按钮，等待AI生成代码
5. 🧪 **测试执行**：从"自定义算法"下拉菜单选择算法并点击"执行"

### 操作说明

| 操作 | 功能 | 图标 |
|------|------|------|
| 左键点击/拖拽 | 绘制/擦除障碍物 | 🧱 |
| 右键点击 | 设置起点 | 🚩 |
| 中键点击 | 设置终点 | 🎯 |

### 新功能详解

#### 📏 场地大小功能
- **快速选择**：预设三种常用尺寸，一键切换
- **自定义支持**：也可手动输入具体的宽度和高度
- **性能优化**：大场地模式下自动优化渲染性能

#### ⚡ 探路速度功能
- **最快模式**: 适合快速验证算法正确性
- **中等模式**: 平衡了演示效果和观看体验
- **最慢模式**: 教学演示最佳选择，每一步都清晰可见

---

## 🔬 算法详解

### A* 算法 ⭐

**特点**: 使用启发式函数指导搜索
```python
# 核心思想：f(n) = g(n) + h(n)
# g(n) = 从起点到当前节点的实际代价
# h(n) = 从当前节点到终点的估计代价（启发式）
```

**优势**:
- ✅ 保证找到最优路径
- ✅ 效率较高，适用于大多数场景
- ✅ 可通过不同启发式函数调优

**适用场景**: 路径规划、游戏NPC寻路、导航系统

### Dijkstra 算法 🎯

**特点**: 不使用启发式函数，纯贪心搜索
```python
# 核心思想：每次选择距离起点最近的未访问节点
# 逐步扩展搜索范围，直到到达终点
```

**优势**:
- ✅ 保证找到最优路径
- ✅ 适用于边权重不同的图
- ✅ 算法简单，容易理解和实现

**适用场景**: 网络路由、地图导航、资源分配

### 广度优先搜索 (BFS) 🌊

**特点**: 逐层搜索，优先访问邻近节点
```python
# 核心思想：使用队列，先访问距离起点近的节点
# 一层一层向外扩展搜索
```

**优势**:
- ✅ 在无权图中保证找到最短路径
- ✅ 简单直观，易于实现
- ✅ 内存占用相对较少

**适用场景**: 社交网络关系查找、迷宫求解、状态空间搜索

---

## 📁 项目结构

```
寻路算法可视化/
├── 🚀 app.py                      # Flask后端服务器
├── 🧮 pathfinding.py              # 寻路算法实现
├── 🤖 llm_integration.py          # LLM算法生成集成
├── 📦 requirements.txt            # 依赖包列表
├── 🖱️ 启动寻路可视化.bat          # Windows启动脚本
├── 📚 README.md                  # 项目说明文档（本文件）
├── 📖 LLM使用指南.md              # LLM功能详细使用指南
├── 📄 LICENSE                    # MIT许可证
├── 🚫 .gitignore                 # Git忽略文件
├── 🔧 .env.example               # 环境变量配置示例
├── 📖 GITHUB_UPLOAD_GUIDE.md     # GitHub上传指南
├── 🎨 templates/
│   └── index.html               # 主页面HTML
└── 💻 static/
    ├── 🎨 style.css             # 样式文件
    └── ⚙️ script.js             # 前端JavaScript逻辑
```

---

## 🛠️ 技术栈

### 后端技术
- **编程语言**: Python 3.6+ 🐍
- **Web框架**: Flask 2.3.3 🌶️
- **算法**: 自实现的寻路算法库 🧮
- **数据结构**: 优先队列、堆、图论算法 📊

### 前端技术
- **标记语言**: HTML5 📄
- **样式技术**: CSS3 🎨
- **交互逻辑**: JavaScript ES6+ ⚡
- **响应式设计**: Flexbox + Grid 📱

### 特色功能
- **实时动画**: 异步渲染引擎 🎬
- **交互式编辑**: 事件驱动的网格系统 🖱️
- **性能优化**: 批次处理和节流技术 ⚡
- **跨平台**: 响应式设计适配多设备 🌐
- **LLM集成**: 多平台AI算法生成系统 🤖
- **代码执行**: 安全沙箱环境和动态类加载 🔒
- **API管理**: 多服务商密钥管理和连接测试 🔑

---

## ⚠️ 注意事项

### 使用建议
- 🚫 **寻路过程中**不能编辑网格
- ✅ **务必设置**起点和终点再开始寻路
- 📱 **支持响应式设计**，可在移动设备上使用
- 💪 **大场地模式**建议使用性能较好的设备
- ⚡ **如遇性能问题**，可选择较快的动画速度

### LLM功能使用建议
- 🔐 **API密钥安全**: 不要在不安全的环境中使用API密钥，定期更换
- 📝 **算法描述**: 尽量使用具体和技术性的语言描述算法
- 🧪 **算法测试**: 先在简单场景中测试生成的算法，再尝试复杂场景
- 💰 **成本控制**: 注意API调用的token消耗，避免频繁生成和测试
- 🌐 **网络要求**: LLM功能需要稳定的网络连接，建议在网络环境良好时使用

### 最佳实践
- **学习算法**: 建议使用慢速模式，仔细观察搜索过程
- **性能测试**: 使用大场地 + 快速模式测试算法效率
- **算法比较**: 相同场景下切换不同算法对比效果
- **复杂场景**: 多设置一些障碍物，观察算法绕障能力

### LLM算法生成最佳实践
- **从简单开始**: 先尝试生成基础算法如贪心搜索、随机寻路等
- **逐步复杂**: 掌握基本操作后再尝试生成复杂算法
- **对比验证**: 将AI生成的算法与经典算法在同一场景下对比
- **详细描述**: 使用专业的算法术语和数据结构描述要求
- **错误处理**: 如果生成的代码有问题，重新调整描述再次生成

---

## 🤝 贡献指南

欢迎对这个项目进行完善和改进！

### 如何贡献
1. **🍴 Fork** 这个项目
2. **🌿 创建** 你的功能分支 (`git checkout -b feature/new-feature`)
3. **💾 提交** 你的更改 (`git commit -m 'Add new feature'`)
4. **📤 推送** 到分支 (`git push origin feature/new-feature`)
5. **🔄 创建** 一个Pull Request

### 贡献类型
- **🐛 Bug修复**: 修复合法性问题
- **✨ 新功能**: 添加新的算法或功能
- **📚 文档改进**: 完善使用说明和文档
- **🎨 界面优化**: 改进用户体验和视觉效果
- **⚡ 性能优化**: 提升运行效率
- **🧪 测试覆盖**: 增加单元测试或集成测试

### 开发规范
- 遵循PEP 8 Python代码规范
- 提交信息清晰明了
- 新功能需要包含相应的文档说明
- 确保所有功能在不同环境下正常工作

---

## 📈 项目价值

### 🎓 教学价值
- **算法可视化**: 将抽象算法转化为直观动画
- **对比学习**: 不同算法在同一场景下的表现对比
- **交互式体验**: 手动设置场景，加深理解
- **实时反馈**: 立即看到参数调整的效果

### 💻 技术价值
- **完整示例**: Flask + 前端全栈项目
- **算法实现**: 经典算法的实际应用
- **性能优化**: 大规模数据的处理优化
- **用户体验**: 交互式设计的最佳实践

### 🚀 应用场景
- **算法教学**: 计算机科学课程辅助工具
- **技术面试**: 算法理解的可视化演示
- **游戏开发**: 寻路算法的原型验证
- **路径规划**: 导航算法的参考实现

---

## 📄 许可证

本项目采用 **MIT 许可证** - 查看 [LICENSE](LICENSE) 文件了解详情。

> 💡 **MIT许可证简介**:
> - ✅ 商业使用
> - ✅ 修改和分发
> - ✅ 私人使用
> - ❗ 需要包含许可证和版权声明
> - ❗ 软件按"原样"提供，不提供任何担保

---

## 📞 联系方式

- **🏠 项目主页**: https://github.com/LimbusSpace/pathfinding-visualizer
- **🐛 问题反馈**: 通过GitHub Issues提交
- **💬 功能建议**: 欢迎在Issues中提出新功能建议
- **📧 联系作者**: 在项目主页查看联系方式

---

## 🌟 致谢

感谢所有为这个项目做出贡献的开发者，以及开源社区提供的技术支持：

- **Python社区** 🐍 - 提供了强大的编程语言和丰富的库
- **Flask框架** 🌶️ - 轻量级Web框架，让开发变得简单
- **开源社区** 🌍 - 共享知识，共同进步的精神
- **算法研究者** 🧮 - 为我们提供了这些经典的寻路算法

---

## 📝 最后更新

- **🏷️ 文档版本**: 1.0
- **📅 最后更新**: 2025-10-04
- **👤 作者**: LimbusSpace
- **🔧 维护状态**: 🟢 活跃维护，欢迎贡献
- **🎯 项目状态**: 🟢 功能完整，稳定可用

---

## 🎯 未来计划

### 短期目标
- [ ] 添加更多寻路算法（如Jump Point Search、Theta*）
- [ ] 支持导入/导出地图配置
- [ ] 添加算法性能统计和对比图表
- [ ] 支持更大规模的地图渲染
- [ ] 添加LLM生成算法的模板和预设方案
- [ ] 支持LLM算法代码的编辑和优化功能

### 长期目标
- [ ] 开发移动端APP版本
- [ ] 添加3D地形寻路支持
- [ ] 实现多人协作编辑功能
- [ ] 支持实时算法竞赛模式
- [ ] 集成更多LLM提供商和算法优化建议
- [ ] 开发算法学习和教学功能模块

---

**🚀 开始你的寻路算法可视化之旅吧！**

> 💪 **编程小贴士**: 理解算法最好的方式就是实现它，可视化它，然后教给别人！